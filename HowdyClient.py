#!usr/bin/env python3# _*_ coding: utf-8 _*_'HowdyClient'__author__ = 'Jingjun Zhang'import socketimport threadingimport tkinterimport reimport sysclass MultiSockClient:    def __init__(self):        #buffer size        self.BUFFSIZE = 4096        #default server address and port num        self.srvaddr = '127.0.0.1'        self.srvport = 20002        self.mainsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        #all users/destinations for messages        self.options=['Server', 'All']        #local username        self.myname=''        #create the mainframe        self.main_app = tkinter.Tk()        self.main_app.title('HowdyClient')        self.main_app.protocol('WM_DELETE_WINDOW', self.winclose)        self.mainframe = tkinter.Frame(self.main_app)        self.mainframe.pack()        #add widgets into frame.        self.labelop = tkinter.Label(self.mainframe, text='Send To')        self.listboxul = tkinter.Listbox(self.mainframe, selectmode=tkinter.SINGLE)        #add destination list into list box.        self.optupdate()        self.textboxmsg = tkinter.Text(self.mainframe)        self.textboxmsg.insert(tkinter.END, '''        Howdy!!!!        Thank you for being a Howdy user.        Before sending any message, you should connect to Howdy server with valid IP address and port number. If you do not specify any IP addresses and port numbers, you can still connect the local server with port number 20002.        After connecting the server, the first thing you need to do is to send you user name. Server and All are reserved so you cannot use them as user name. And if the name is not accepted by the server, you have to choose another one till it is accepted. "Send To Server" should be selected when you are sending your username.        While you are sending any message, you have to specify one option from options list. You can send it to one user or to everyone.        Now let us chat.        *******************************************        ''')        self.labelyou = tkinter.Label(self.mainframe, text='You say: ')        self.entrymsg = tkinter.Entry(self.mainframe)        self.buttonsend = tkinter.Button(self.mainframe, text='Send')        self.labelip = tkinter.Label(self.mainframe, text='IP addr:')        self.entryip = tkinter.Entry(self.mainframe)        self.labelport = tkinter.Label(self.mainframe, text='Port:')        self.entryport = tkinter.Entry(self.mainframe)        self.buttonconn = tkinter.Button(self.mainframe, text='Connect')        #bind functions with two buttons        self.buttonconn.bind('<Button-1>', self.connectsrv)        self.buttonsend.bind('<Button-1>', self.msgsend)        #bind function to entry, so user can user enter key to send.        self.entrymsg.bind('<Return>', self.msgsend)        #create layouts        self.labelop.grid(row=0, column=0, rowspan=2, columnspan=8, sticky=tkinter.NSEW)        self.listboxul.grid(row=2, column=0, rowspan=18, columnspan=8, sticky=tkinter.NSEW)        self.textboxmsg.grid(row=0, column=8, rowspan=20, columnspan=24, sticky=tkinter.NSEW)        self.labelyou.grid(row=20, column=0, rowspan=2, columnspan=4, sticky=tkinter.NSEW)        self.entrymsg.grid(row=20, column=4, rowspan=2, columnspan=24, sticky=tkinter.NSEW)        self.buttonsend.grid(row=20, column=28, rowspan=2, columnspan=4, sticky=tkinter.NSEW)        self.labelip.grid(row=22, column=0, rowspan=2, columnspan=4, sticky=tkinter.NSEW)        self.entryip.grid(row=22, column=4, rowspan=2, columnspan=10, sticky=tkinter.NSEW)        self.labelport.grid(row=22, column=14, rowspan=2, columnspan=4, sticky=tkinter.NSEW)        self.entryport.grid(row=22, column=18, rowspan=2, columnspan=10, sticky=tkinter.NSEW)        self.buttonconn.grid(row=22, column=28, rowspan=2, columnspan=4, sticky=tkinter.NSEW)        #start main GUI.        self.main_app.mainloop()    def winclose(self):        #clear socket and GUI when user close window.        try:            self.mainsock.shutdown(socket.SHUT_RDWR)            self.mainsock.close()        except:            print('No connection need to be terminated.')        finally:            self.main_app.destroy()            sys.exit(0)    def connectsrv(self, event):        # get ip addr and port num from user input        iptemp = self.entryip.get()        porttemp = self.entryport.get()        try:            # get valid ip addr and port number            if re.match('^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', iptemp) != None and int(porttemp) == self.srvport:                # update ip addr and port num                self.srvaddr = iptemp                self.srvport = int(porttemp)                self.textboxmsg.insert(tkinter.END, '\n' + 'You are going to connect Howdy Server with ' + self.srvaddr + ':' + str(self.srvport))                self.textboxmsg.see(tkinter.END)                # connect with user specified ip addr and port num and start a new thread                self.mainsock.connect((self.srvaddr, self.srvport))                self.cltrecv = threading.Thread(target=self.msgrecv, args=(self.mainsock,))                self.cltrecv.daemon = True                self.cltrecv.start()            elif len(iptemp) == 0 and len(porttemp) == 0:                # connect with default ip addr and port num and start a new thread                self.textboxmsg.insert(tkinter.END, '\n' + 'You are going to connect Howdy Server with ' + self.srvaddr + ':' + str(self.srvport))                self.textboxmsg.see(tkinter.END)                self.mainsock.connect((self.srvaddr, self.srvport))                self.cltrecv = threading.Thread(target=self.msgrecv, args=(self.mainsock,))                self.cltrecv.daemon = True                self.cltrecv.start()            else:                # fail to connect                self.textboxmsg.insert(tkinter.END, '\n' + 'The IP address or port number is not valid, please try again.')                self.textboxmsg.see(tkinter.END)                return        except:            #restore default value if exception happens.            self.srvaddr = '127.0.0.1'            self.srvport = 20002            return    def msgsend(self, event):        #get seq no of item in list box        recvseq = self.listboxul.curselection()        #check if user specify the destination.        if len(recvseq)==0:            self.textboxmsg.insert(tkinter.END, '\n' + 'You did not specify any receiver.')            self.textboxmsg.see(tkinter.END)            return        #get destination of message        dest = self.listboxul.get(recvseq)        #get outgoing msg from text entry.        msg = self.entrymsg.get()        #check if it is empty.        if len(msg)==0:            return        print('You sent: ', msg)        #convert message to bytes.        bmsg = bytes(msg, 'utf-8')        #send username to server        if dest == 'Server':            #stop sending anything if having a valid local username.            if len(self.myname)!=0:                return            print('Sending username to server')            #check length of username            blen = len(bmsg)            if blen>64:                self.textboxmsg.insert(tkinter.END, '\n'+'The username is too long.')                self.textboxmsg.see(tkinter.END)            #send username to server            pkt = b'\x01'+bmsg+b'\x00'*(64-blen)            self.mainsock.send(pkt)        #send msg to a single user        elif dest != "All":            #stop sending if do not have a username.            if len(self.myname)==0:                print('You need set a username first.')                self.textboxmsg.insert(tkinter.END, '\n' + 'You need set a username first.')                self.textboxmsg.see(tkinter.END)                return            #display the message you are sending on client GUI.            self.textboxmsg.insert(tkinter.END, '\n' + 'You whisper to '+dest+': '+ msg)            self.textboxmsg.see(tkinter.END)            print('Sending message to '+dest)            #generate message to a single user.            senderlen = len(self.myname)            recverlen = len(dest)            pkt = b'\x05' + bytes(self.myname, 'utf-8') + b'\x00'*(64-senderlen) + bytes(dest, 'utf-8') + b'\x00'*(64-recverlen) + bmsg[0:self.BUFFSIZE-129]            self.mainsock.send(pkt)        #send msg to all        else:            #stop sending if do not have a username.            if len(self.myname) == 0:                print('You need set a username first.')                self.textboxmsg.insert(tkinter.END, '\n' + 'You need set a username first.')                self.textboxmsg.see(tkinter.END)                return            #display the message you are sending on client GUI.            self.textboxmsg.insert(tkinter.END, '\n' + 'You say: '+msg)            self.textboxmsg.see(tkinter.END)            print('Sending mesage to all')            #generate message to all.            senderlen = len(self.myname)            pkt = b'\x05' + bytes(self.myname, 'utf-8') + b'\x00'*(64-senderlen) + bytes('All', 'utf-8') + b'\x00'*(64-len('All')) + bmsg[0:self.BUFFSIZE-129]            self.mainsock.send(pkt)        #reset text after sending a packet        self.entrymsg.delete(0,'end')    def msgrecv(self, conn):        while True:            # receive a msg            try:                bmsg = conn.recv(self.BUFFSIZE)            except:                return            #if length of message is 0, close socket.            if len(bmsg) == 0:                self.mainsock.close()                return            print('Raw message type: ', bmsg[0])            print('Raw message: ', bmsg)            #parse a username ack type 2.            if bmsg[0] == 2:                print('Parsing packet type 2')                #update local username.                self.myname=str(bmsg[1:65].rstrip(b'\x00'), 'utf-8')                print('My username is', self.myname)                self.textboxmsg.insert(tkinter.END, '\n'+'Your username is accepted')                self.textboxmsg.see(tkinter.END)            #parse a username nak type 3.            elif bmsg[0] == 3:                print('Parsing packet type 3')                self.textboxmsg.insert(tkinter.END, '\n'+'The username is not accepted by server, please try another one.')                self.textboxmsg.see(tkinter.END)            #parse a username update type 4.            elif bmsg[0] == 4:                print('Parsing packet type 4')                #save original destination list.                templist= self.options.copy()                #number of names in the new list.                numnames= (len(bmsg)-1)//64                #clear list and add new users into the list.                self.options.clear()                self.options.append('Server')                self.options.append('All')                for i in range(numnames):                    s=str(bmsg[1+64*i:65+64*i].rstrip(b'\x00'), 'utf-8')                    self.options.append(s)                print('Current options: ', self.options)                #update window display.                self.optupdate()                #information of new user online and old user offline                #find logoff users.                offnum=0                for u in templist:                    if u not in self.options:                        self.textboxmsg.insert(tkinter.END, '\n'+u)                        offnum=offnum+1                if offnum>0:                    self.textboxmsg.insert(tkinter.END, '\n' + 'left this conversation.')                #find logon users.                onnum=0                for u in self.options:                    if u not in templist:                        self.textboxmsg.insert(tkinter.END, '\n'+u)                        onnum=onnum+1                if onnum>0:                    self.textboxmsg.insert(tkinter.END, '\n' + 'join this conversation.')                self.textboxmsg.see(tkinter.END)            #parse a regular msg type 5.            elif bmsg[0] == 5:                print('Parsing packet type 5')                #get information of sender and receiver.                sendername = str(bmsg[1:65].rstrip(b'\x00'), 'utf-8')                recvername = str(bmsg[65:129].rstrip(b'\x00'), 'utf-8')                #convert bytes to string message.                msg = str(bmsg[129:].rstrip(b'\x00'), 'utf-8')                #discard packets from invalid users.                if sendername not in self.options:                    continue                #handle boradcast message.                if recvername =='All':                    self.textboxmsg.insert(tkinter.END, '\n'+sendername+' says: '+msg)                    self.textboxmsg.see(tkinter.END)                #handle unicast message.                elif recvername == self.myname:                    self.textboxmsg.insert(tkinter.END, '\n'+sendername + ' whispers to you: ' + msg)                    self.textboxmsg.see(tkinter.END)                #handle invalide message.                else:                    continue            #clients discards other message types silently.            else:                print('Unknown packet type')                continue    #update listbox    def optupdate(self):        #get number of current items in the list.        optsz = self.listboxul.size()        #clear items.        self.listboxul.delete(0, optsz-1)        #update list with current destination list.        for s in self.options:            self.listboxul.insert(tkinter.END, s)        self.listboxul.update()if __name__=='__main__':    startapp = MultiSockClient()