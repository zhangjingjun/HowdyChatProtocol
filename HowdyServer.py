#!usr/bin/env python3# _*_ coding: utf-8 _*_'HowdyServer'__author__ = 'Jingjun Zhang'import socketimport threadingimport reBUFFSIZE = 4096MAXCONN = 10class Chatconnection(threading.Thread):    #create a dictionary mapping username and socket    clients = {}    def __init__(self, csock, caddr):        #initiate thread of self and create a new object        threading.Thread.__init__(self)        self.cltsock=csock        self.cltaddr=caddr    def run(self):        #start a thread which handle communication with a single user        while True:            # if user disconnects, server sould send update packet, remove coon from dict, and close conn.            bmsg = self.cltsock.recv(BUFFSIZE)            # no more message received, remote client is closed.            if len(bmsg) == 0:                #define a temp variable to store name of offline user.                offuser=''                #finde the username of offline user.                for u in Chatconnection.clients.keys():                    if Chatconnection.clients[u]==self.cltsock:                        offuser=u                #offline user is in the list.                if len(offuser)!=0:                    #delete the connection from dictionary.                    del Chatconnection.clients[offuser]                    print(offuser+' is offline now.')                    #send update packet to other users.                    if len(Chatconnection.clients) != 0:                        pkt = b'\x04'                        for s in Chatconnection.clients.keys():                            pkt = pkt + bytes(s, 'utf-8') + b'\x00' * (64 - len(s))                        for c in Chatconnection.clients:                            Chatconnection.clients[c].send(pkt)                        print('Sending packet type 4 to all receivers')                    #no other users online                    else:                        print('No user online now.')                    #close connection                    self.cltsock.close()                else:                    #close connection                    self.cltsock.close()                    if len(Chatconnection.clients) == 0:                        print('No user online now.')                #stop running thread                return            print('New message received. Message type: ', bmsg[0])            # receive message type 1, start username negotiation            if bmsg[0] == 1:                print('Parsing packet type 1 from ', self.cltaddr)                #extract username from message                username = str(bmsg[1:65].rstrip(b'\x00'), 'utf-8')                print('A username is received: ', username)                # finde a new user, accept the new user, sending ack type 2 and update type 4.                if username not in Chatconnection.clients:                    #insert client socket into dictionary, and map it with user.                    Chatconnection.clients[username] = self.cltsock                    print('A username is accepted: ' + username)                    print('Accepted user comes from ', self.cltaddr)                    print('New user is added into list. Current User list: ', Chatconnection.clients)                    #generate message type 2 and send.                    ack = b'\x02' + bmsg[1:65]                    self.cltsock.send(ack)                    print('Sending packet type 2 to ', self.cltaddr)                    #generate message type 4 and send.                    pkt = b'\x04'                    #insert user list into message                    for s in Chatconnection.clients.keys():                        pkt = pkt + bytes(s, 'utf-8') + b'\x00' * (64 - len(s))                    #send update user list to existing users.                    for c in Chatconnection.clients:                        Chatconnection.clients[c].send(pkt)                    print('Sending packet type 4 to all receivers')                # username is in the list, reject the request, send a nak type 3.                else:                    #generate nak message.                    nak = b'\x03' + bmsg[1:65]                    self.cltsock.send(nak)                    print('Sending packet type 3 to ', self.cltaddr)            # receive a regular message type 5, forward to proper destination.            elif bmsg[0] == 5:                print('Parsing packet type 5 from ', self.cltaddr)                #extract username of sender and receiver.                sendername = str(bmsg[1:65].rstrip(b'\x00'), 'utf-8')                recvername = str(bmsg[65:129].rstrip(b'\x00'), 'utf-8')                print('Sender name is ' + sendername)                print('Receiver name is ' + recvername)                #sender is not registered, discard packet silently.                if sendername not in Chatconnection.clients.keys():                    print('Error: Invalid sender name.')                    continue                #sender is not in right connection, discard packet silently.                if Chatconnection.clients[sendername] != self.cltsock:                    print('Error: mismatch of username and connection.')                    continue                #message is send to all users.                if recvername == 'All':                    #forward message to everyone except sender.                    for c in Chatconnection.clients:                        if Chatconnection.clients[c]!=self.cltsock:                            Chatconnection.clients[c].send(bmsg)                    print('Forwarding message type 5 to all receivers')                #message is send to a specific user.                elif recvername in Chatconnection.clients.keys():                    #forward message to a specific user.                    Chatconnection.clients[recvername].send(bmsg)                    print('Forwarding message type 5 to ' + recvername)                #error in username of receiver.                else:                    print('Error: Invalid receiver name.')                    continue            else:                #server will not deal with any other message types, the packet should be discarded silently.                print('Error: Invalid message type.')                continueif __name__=='__main__':    #default ip address and port number of Howdy server.    srvip = '127.0.0.1'    srvtcpport = 20002    #ask user for IP address    while True:        strip = input('Please input a valid IP address of this Howdy Server, press Enter to use 127.0.0.1.'+'\n')        #if no input, use default value.        if len(strip)==0:            break        #if user input is a valid ip address, update server ip addresss.        if re.match('^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', strip)!=None:            srvip=strip            break    #ask user for tcp port number    while True:        try:            strport=input('Please input a valid TCP port number for Howdy Server, press Enter to use 20002.'+'\n')            #if no input, use default value.            if len(strport)==0:                break            #update port number with user input            srvtcpport = int(strport)            #get a valid port num, break the loop            if srvtcpport >= 1025 and srvtcpport <= 65535:                break            else:                #get a invalid port num, restore default value.                srvtcpport = 20002        except:            #if user input is not a number, keep asking for port number.            continue    srvaddr = (srvip, srvtcpport)    print('You are going to start Howdy Server with ', srvaddr)    #create main socket    srvsock=socket.socket(socket.AF_INET, socket.SOCK_STREAM)    #allow reuse address    srvsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    srvsock.bind(srvaddr)    srvsock.listen(MAXCONN)    print('Server is started and listening.')    while True:        #a client connection is established.        sock, addr = srvsock.accept()        print('A new client is connected: ', addr)        #create a new thread for client connetion.        newthread = Chatconnection(sock, addr)        newthread.daemon=True        newthread.start()